<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Cash Flow Manager</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #3498db;
      --primary-dark: #2980b9;
      --accent-color: #27ae60;
      --accent-dark: #1e8449;
      --error-color: #e74c3c;
      --error-dark: #c0392b;
      --text-color: #333;
      --background-color: #f4f7f6;
      --card-bg: #ffffff;
      --card-shadow: rgba(0, 0, 0, 0.1);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, var(--background-color) 0%, #ffffff 100%);
      color: var(--text-color);
      line-height: 1.6;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      font-size: 2.5em;
      text-align: center;
      margin-bottom: 40px;
      color: var(--primary-dark);
    }
    h2 {
      font-size: 1.8em;
      margin-bottom: 20px;
      padding-bottom: 5px;
      border-bottom: 2px solid var(--primary-color);
    }
    h3 {
      font-size: 1.4em;
      margin-bottom: 15px;
    }
    /* Force radio buttons to sit in the middle of their line */
.expense-plan-type input[type="radio"] {
  vertical-align: middle;
  margin-top: -1px; /* or 0, adjust as needed */
  margin-right: 6px; /* small space between radio and text */
}
    section {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 20px;
      box-shadow: 0 4px 6px var(--card-shadow);
    }
    form input, form select, form button {
      display: block;
      width: 100%;
      max-width: 400px;
      font-size: 1em;
      padding: 12px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      transition: all 0.2s ease;
    }
    form input:focus, form select:focus {
      border-color: var(--primary-color);
      outline: none;
      box-shadow: 0 0 4px rgba(52,152,219,0.5);
    }
    form button {
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 6px;
      padding: 12px 20px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.3s ease;
    }
    form button:hover {
      background-color: var(--primary-dark);
    }
    ul {
      list-style: none;
      padding: 0;
    }
    li {
      background: #f9f9f9;
      margin-bottom: 8px;
      padding: 12px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .item-text {
      flex: 1;
      margin-right: 10px;
    }
    .delete-btn {
      background-color: var(--error-color);
      border: none;
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .delete-btn:hover {
      background-color: var(--error-dark);
    }
    .edit-btn {
      background-color: var(--accent-color);
      border: none;
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      margin-right: 5px;
      transition: background 0.3s ease;
    }
    .edit-btn:hover {
      background-color: var(--accent-dark);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: var(--primary-color);
      color: #fff;
    }
    #expense-totals {
      border: 2px solid var(--primary-color);
      padding: 20px;
      border-radius: 10px;
      background: #eaf4fc;
    }
    #expense-totals h2 {
      margin-top: 0;
    }
    #expense-totals h3 {
      margin-bottom: 10px;
    }
    #expense-totals p {
      font-size: 0.95em;
      color: #555;
    }
    .totals-list {
      margin: 10px 0;
      padding-left: 20px;
    }
    #balanceTrackingToggleContainer {
      margin-bottom: 15px;
    }
    #balanceTrackingToggleContainer p {
      font-size: 0.9em;
      color: #555;
    }
    /* New container for Expected Paycheck Amount */
    .paycheck-amount-section {
      border: 2px solid var(--primary-color);
      background-color: #f7faff;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .paycheck-amount-section h2 {
      margin-bottom: 15px;
    }
    /* Expense Plan Type container */
    .expense-plan-type {
      border: 1px solid #ccc;
      background-color: #f7faff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    .expense-plan-type > div {
      margin-bottom: 10px;
    }
    .expense-plan-type label {
      font-weight: 500;
      cursor: pointer;
    }
    .expense-plan-type p {
      margin-left: 20px;
      font-size: 0.9em;
      color: #555;
    }
    #distribution-section {
      margin-top: 20px;
      padding: 20px;
      border: 2px dashed var(--primary-color);
      background-color: #f7faff;
      border-radius: 8px;
    }
    #distribution-section select,
    #distribution-section input,
    #distribution-section button {
      padding: 10px;
      margin: 5px 0;
      font-size: 1em;
      max-width: 400px;
    }
    #bank-accounts {
      position: relative;
    }
    #balanceTrackingDynamic .dynamic-input {
      margin-bottom: 15px;
    }
    #customAllocationFields div {
      margin-bottom: 10px;
    }
    #customAllocationCounter {
      font-weight: 500;
      margin-top: 10px;
    }
    #lockedDistributionContainer {
      margin-top: 10px;
    }
    .locked-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f1f1f1;
      padding: 8px;
      border-radius: 6px;
      margin-bottom: 5px;
    }
    .locked-delete-btn {
      background-color: var(--error-color);
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s ease;
    }
    .locked-delete-btn:hover {
      background-color: var(--error-dark);
    }
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Enhanced Cash Flow Manager</h1>

    <!-- Paydays Section (for non‑tracking scenarios) -->
    <section id="paydays">
      <h2>Paydays</h2>
      <form id="paydayForm">
        <label for="paydayType">Payday Type:</label>
        <select id="paydayType" required>
          <option value="">Select Type</option>
          <option value="specific">Specific Day</option>
          <option value="1st15">1st and 15th</option>
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </select>
        <!-- For "specific" type -->
        <div id="specificDayInput" class="hidden">
          <label for="specificDay">Day of Month (1–31):</label>
          <input type="number" id="specificDay" placeholder="e.g., 15" min="1" max="31">
        </div>
        <button type="submit">Add Payday</button>
      </form>
      <ul id="paydayList"></ul>
    </section>

    <!-- CSV Import Section for Recurring Bills -->
    <section id="csv-import">
      <h2>CSV Import for Recurring Bills</h2>
      <p>
        You can import recurring bills from a CSV file. The CSV must have exactly these columns:
        <code>Bill Name, Bill Amount, Due Date, Bank Account</code>.<br>
        <strong>Important:</strong> Any bank listed in the CSV that is not already in the manual Bank Accounts section will be automatically added.
      </p>
      <p>Sample table:</p>
      <table>
        <tr>
          <th>Bill Name</th>
          <th>Bill Amount</th>
          <th>Due Date</th>
          <th>Bank Account</th>
        </tr>
        <tr>
          <td>Rent</td>
          <td>1200</td>
          <td>1</td>
          <td>Main Checking</td>
        </tr>
        <tr>
          <td>Electricity</td>
          <td>100</td>
          <td>15</td>
          <td>Main Checking</td>
        </tr>
      </table>
      <br>
      <label for="recurringCSV">Upload Recurring Bills CSV:</label>
      <input type="file" id="recurringCSV" accept=".csv">
    </section>

    <!-- Bank Accounts Section -->
    <section id="bank-accounts">
      <h2>Bank Accounts</h2>
      <div id="balanceTrackingToggleContainer">
        <label>
          <input type="checkbox" id="balanceTrackingToggle">
          Track Bank Account Balances?
        </label>
        <p>When enabled, the system will use the expected paycheck allocations (and ignore your current balance) to determine your surplus.</p>
      </div>
      <form id="bankAccountForm">
        <input type="text" id="bankName" placeholder="Bank Account Name" required>
        <input type="number" id="bankBalance" placeholder="Current Bank Balance (optional)" step="0.01">
        <button type="submit">Add Bank Account</button>
      </form>
      <ul id="bankAccountList"></ul>
      <!-- Dynamic section for balance tracking (appears only if tracking is enabled) -->
      <div id="balanceTrackingDynamic" class="hidden">
        <!-- New Expected Paycheck Amount container -->
       <form id="paycheckForm"> 
        <div id="expectedPaycheckSection" class="paycheck-amount-section">
          <h2>Expected Paycheck Amount (After-Tax)</h2>
          <input type="number" id="expectedPaycheck" placeholder="e.g., 2000" step="0.01">
        </div>
        <div id="distribution-section">
          <h2>Paycheck Distribution Method</h2>
          <select id="distributionMethod">
            <option value="equal">Equal Split</option>
            <option value="custom">Custom Allocation</option>
            <option value="single">Single Account</option>
            <option value="proportional">Proportional to Expenses</option>
          </select>
          <div id="customAllocationFields" class="hidden"></div>
          <div id="singleAccountSelectorContainer" class="hidden">
            <label for="singleAccountSelector">Select Account for Full Paycheck:</label>
            <select id="singleAccountSelector">
              <!-- Options will be populated with bank accounts -->
            </select>
          </div>
        </div>
       </form>
      </div>
    </section>

    <!-- Recurring Bills Section -->
    <section id="recurring-bills">
      <h2>Recurring Bills</h2>
      <form id="billForm">
        <input type="text" id="billName" placeholder="Bill Name (e.g., Rent)" required>
        <input type="number" id="billAmount" placeholder="Bill Amount" required step="0.01">
        <input type="number" id="billDueDate" placeholder="Due Date (Day 1–31)" required min="1" max="31">
        <select id="billBankAccount" required>
          <option value="">Select Bank Account</option>
        </select>
        <button type="submit">Add Recurring Bill</button>
      </form>
      <ul id="billList"></ul>
    </section>

    <!-- Periodic Expenses Section -->
    <section id="oneTime-expenses">
      <h2>Periodic Expenses</h2>
      <p>
        Periodic Expenses are costs that do not occur every month but need to be planned for on a regular basis.
        For example, car insurance that is due twice a year or a gym membership that is only due in certain months.
      </p>
      <form id="expenseForm">
        <input type="text" id="expenseName" placeholder="Expense Name (e.g., Car Insurance)" required>
        <input type="number" id="expenseAmount" placeholder="Expense Amount" required step="0.01">
        <input type="number" id="expenseDueDate" placeholder="Due Day (1–31)" required min="1" max="31">
        <select id="expenseBankAccount" required>
          <option value="">Select Bank Account</option>
        </select>
        <h3>Expense Plan Type</h3>
        <!-- Wrapped radio buttons in a new container -->
        <div class="expense-plan-type">
          <div>
            <label>
              <input type="radio" name="expensePlanType" value="occurrence" checked>
              Occurrences Per Year
            </label>
            <p>
              Use this option if the expense occurs a fixed number of times per year.
              For example, if your car insurance is due twice a year, set Occurrences Per Year to 2.
            </p>
          </div>
          <div>
            <label>
              <input type="radio" name="expensePlanType" value="specific">
              Specific Months
            </label>
            <p>
              Use this option if you know the exact months when the expense is due.
              For example, if your gym membership is due in January and July, add 1 and 7 respectively.
            </p>
          </div>
        </div>
        <div id="occurrenceSection">
          <input type="number" id="expenseOccurrences" placeholder="Occurrences Per Year (e.g., 2)" min="0">
        </div>
        <div id="specificMonthsSection" class="hidden">
          <label for="expenseMonthSelect">Select Month:</label>
          <select id="expenseMonthSelect">
            <option value="1">January</option>
            <option value="2">February</option>
            <option value="3">March</option>
            <option value="4">April</option>
            <option value="5">May</option>
            <option value="6">June</option>
            <option value="7">July</option>
            <option value="8">August</option>
            <option value="9">September</option>
            <option value="10">October</option>
            <option value="11">November</option>
            <option value="12">December</option>
          </select>
          <button type="button" id="addExpenseMonthBtn">Add Month</button>
          <ul id="expenseMonthsList"></ul>
        </div>
        <button type="submit">Add Periodic Expense</button>
      </form>
      <ul id="expenseList"></ul>
    </section>

    <!-- Calculate Required Balances Section -->
    <section id="calculation">
      <h2>Calculate Required Balances</h2>
      <label for="cycleDate">Select Cycle Date:</label>
      <input type="date" id="cycleDate" required>
      <button id="calculateButton">Calculate</button>
    </section>

    <!-- Required Balances Summary Section -->
    <section id="output">
      <h2>Required Balances Summary</h2>
      <div id="results"></div>
    </section>

    <!-- Expense Totals Section -->
    <section id="expense-totals">
      <h2>Expense Totals</h2>
      <div id="payPeriodTotals">
        <h3>Pay-Period Expense Totals</h3>
        <p id="payPeriodRange">This section displays the total expenses for the current pay period.</p>
        <div id="payPeriodCombined"></div>
      </div>
      <div id="monthlyTotals">
        <h3>Monthly Expense Totals</h3>
        <p>This section shows the total monthly expenses along with a breakdown by bank account and lists all bills.</p>
        <div id="monthlyCombined"></div>
        <div id="monthlyByBank"></div>
      </div>
    </section>
  </div>

  <script>
    /**************************************************************
     * Global variables and data storage.
     **************************************************************/
    let bankAccounts = [];
    let recurringBills = [];
    let oneTimeExpenses = [];
    let paydays = [];
    let balanceTrackingEnabled = false;
    let tempExpenseMonths = [];
    let lockedDistribution = {}; // Holds locked custom distribution values

    /**************************************************************
     * Helper: Get days in month based on the selected cycle date.
     **************************************************************/
    function getCycleDaysInMonth() {
      const cycleDateVal = document.getElementById('cycleDate').value;
      if (cycleDateVal) {
        let dt = new Date(cycleDateVal);
        return new Date(dt.getFullYear(), dt.getMonth()+1, 0).getDate();
      }
      return 31;
    }

    /**************************************************************
     * Helper: Check if a due date is within the pay period window,
     * accounting for wrap-around if periodEnd < periodStart.
     **************************************************************/
    function isDueWithin(dueDate, periodStart, periodEnd, daysInMonth) {
      if (periodStart <= periodEnd) {
        return (dueDate >= periodStart && dueDate <= periodEnd);
      } else {
        return (
          (dueDate >= periodStart && dueDate <= daysInMonth) ||
          (dueDate >= 1 && dueDate <= periodEnd)
        );
      }
    }

    /**************************************************************
     * Helper: For bills due on 29-31 in a month with fewer days,
     * return the effective due date.
     **************************************************************/
    function effectiveDueDate(dueDate, daysInMonth) {
      return (dueDate > daysInMonth) ? daysInMonth : dueDate;
    }

    /**************************************************************
     * Utility: Update bank account dropdowns in bills and expenses.
     **************************************************************/
    function updateBankAccountDropdowns() {
      const billSelect = document.getElementById('billBankAccount');
      const expenseSelect = document.getElementById('expenseBankAccount');
      billSelect.innerHTML = '<option value="">Select Bank Account</option>';
      expenseSelect.innerHTML = '<option value="">Select Bank Account</option>';
      bankAccounts.forEach(account => {
        const option1 = document.createElement('option');
        option1.value = account.id;
        option1.textContent = account.name;
        billSelect.appendChild(option1);
        const option2 = document.createElement('option');
        option2.value = account.id;
        option2.textContent = account.name;
        expenseSelect.appendChild(option2);
      });
    }

    /**************************************************************
     * Update distribution section options.
     **************************************************************/
    function updateDistributionSection() {
      const singleAccountSelector = document.getElementById('singleAccountSelector');
      singleAccountSelector.innerHTML = "";
      bankAccounts.forEach(account => {
        const option = document.createElement('option');
        option.value = account.id;
        option.textContent = account.name;
        singleAccountSelector.appendChild(option);
      });
      if(document.getElementById('distributionMethod').value === "custom") {
        updateCustomAllocationFields();
      }
    }

    /**************************************************************
     * Update custom allocation fields for each bank account.
     **************************************************************/
    function updateCustomAllocationFields() {
      const customAllocDiv = document.getElementById('customAllocationFields');
      customAllocDiv.innerHTML = "";
      bankAccounts.forEach(account => {
        const div = document.createElement('div');
        div.innerHTML = `<label for="customAlloc_${account.id}">${account.name} Allocation (per pay period):</label>
                         <input type="number" id="customAlloc_${account.id}" placeholder="Amount" step="0.01">`;
        customAllocDiv.appendChild(div);
        const inputElem = div.querySelector('input');
        inputElem.addEventListener('input', updateCustomAllocationCounter);
      });
      const counterDiv = document.createElement('div');
      counterDiv.id = "customAllocationCounter";
      counterDiv.textContent = "Remaining to distribute: $0";
      customAllocDiv.appendChild(counterDiv);
      if(!document.getElementById('addDistributionBtn')) {
        const addBtn = document.createElement('button');
        addBtn.type = "button";
        addBtn.id = "addDistributionBtn";
        addBtn.textContent = "Lock Custom Distribution";
        addBtn.addEventListener('click', lockCustomDistribution);
        customAllocDiv.appendChild(addBtn);
      }
      if(!document.getElementById('lockedDistributionContainer')) {
        const lockDiv = document.createElement('div');
        lockDiv.id = "lockedDistributionContainer";
        customAllocDiv.appendChild(lockDiv);
      }
      customAllocDiv.classList.remove('hidden');
    }

    function updateCustomAllocationCounter() {
      let target = balanceTrackingEnabled 
                   ? parseFloat(document.getElementById('expectedPaycheck').value) 
                   : (paydays.length > 0 ? paydays[0].paycheckAmount : 0);
      let sum = 0;
      bankAccounts.forEach(account => {
        let input = document.getElementById('customAlloc_' + account.id);
        if(input && input.value !== "") {
          sum += parseFloat(input.value);
        }
      });
      let remaining = target - sum;
      const counterElem = document.getElementById('customAllocationCounter');
      if(counterElem) {
        counterElem.textContent = "Remaining to distribute: $" + remaining.toFixed(2);
      }
    }

    /**************************************************************
     * Lock (Add) the custom distribution.
     **************************************************************/
    function lockCustomDistribution() {
      let target = balanceTrackingEnabled 
                   ? parseFloat(document.getElementById('expectedPaycheck').value) 
                   : (paydays.length > 0 ? paydays[0].paycheckAmount : 0);
      let total = 0;
      let allocations = {};
      bankAccounts.forEach(account => {
        let input = document.getElementById('customAlloc_' + account.id);
        let val = (input && input.value !== "") ? parseFloat(input.value) : 0;
        allocations[account.id] = val;
        total += val;
      });
      if(Math.abs(total - target) > 0.01) {
        alert("The total of custom allocations must equal the paycheck amount of $" + target.toFixed(2) + ". Current total: $" + total.toFixed(2));
        return;
      }
      lockedDistribution = allocations;
      bankAccounts.forEach(account => {
        let input = document.getElementById('customAlloc_' + account.id);
        if(input) {
          input.disabled = true;
        }
      });
      updateLockedDistributionDisplay();
    }

    function updateLockedDistributionDisplay() {
      const container = document.getElementById('lockedDistributionContainer');
      container.innerHTML = "";
      for(let accId in lockedDistribution) {
        let amount = lockedDistribution[accId];
        let account = bankAccounts.find(a => a.id === accId);
        let div = document.createElement('div');
        div.classList.add('locked-item');
        div.innerHTML = `<span>${account.name}: $${amount.toFixed(2)}</span>`;
        let delBtn = document.createElement('button');
        delBtn.classList.add('locked-delete-btn');
        delBtn.textContent = "Delete";
        delBtn.addEventListener('click', function() {
          delete lockedDistribution[accId];
          let input = document.getElementById('customAlloc_' + accId);
          if(input) {
            input.disabled = false;
            input.value = "";
          }
          updateCustomAllocationCounter();
          updateLockedDistributionDisplay();
        });
        div.appendChild(delBtn);
        container.appendChild(div);
      }
    }

    /**************************************************************
     * Show/hide the specific day input for paydays.
     **************************************************************/
    document.getElementById('paydayType').addEventListener('change', function() {
      const specificInput = document.getElementById('specificDayInput');
      if (this.value === 'specific') {
        specificInput.classList.remove('hidden');
      } else {
        specificInput.classList.add('hidden');
      }
    });

    /**************************************************************
     * Toggle: Enable or disable balance tracking.
     **************************************************************/
    document.getElementById('balanceTrackingToggle').addEventListener('change', function() {
      balanceTrackingEnabled = this.checked;
      const dynamicContainer = document.getElementById('balanceTrackingDynamic');
      if(balanceTrackingEnabled) {
        dynamicContainer.classList.remove('hidden');
      } else {
        dynamicContainer.classList.add('hidden');
      }
      updateBankAccountList();
    });

    /**************************************************************
     * Distribution Method Change: Show/hide custom allocation or
     * single account selector.
     **************************************************************/
    document.getElementById('distributionMethod').addEventListener('change', function() {
      const method = this.value;
      const customDiv = document.getElementById('customAllocationFields');
      const singleDiv = document.getElementById('singleAccountSelectorContainer');
      if(method === "custom") {
        customDiv.classList.remove('hidden');
        singleDiv.classList.add('hidden');
        updateCustomAllocationFields();
      } else if(method === "single") {
        singleDiv.classList.remove('hidden');
        customDiv.classList.add('hidden');
        updateDistributionSection();
      } else {
        customDiv.classList.add('hidden');
        singleDiv.classList.add('hidden');
      }
    });

    /**************************************************************
     * Add a new Payday.
     **************************************************************/
    document.getElementById('paydayForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const type = document.getElementById('paydayType').value;
      let day = null;
      if (!type) {
        alert("Please select a payday type.");
        return;
      }
      if (type === 'specific') {
        day = parseInt(document.getElementById('specificDay').value);
        if (isNaN(day) || day < 1 || day > 31) {
          alert("Enter a valid day of month (1–31).");
          return;
        }
      }
      // Note: Expected Paycheck Amount is now entered in the dynamic section.
      const id = Date.now().toString() + "_pd";
      paydays.push({ id, type, day });
      updatePaydayList();
      document.getElementById('paydayType').value = "";
      document.getElementById('specificDay').value = "";
      document.getElementById('specificDayInput').classList.add('hidden');
    });

    /**************************************************************
     * Update the Payday list UI.
     **************************************************************/
    function updatePaydayList() {
      const paydayList = document.getElementById('paydayList');
      paydayList.innerHTML = "";
      paydays.forEach(pd => {
        let pdText = "";
        if (pd.type === 'specific') {
          pdText = "Day " + pd.day;
        } else if (pd.type === '1st15') {
          pdText = "1st and 15th";
        } else {
          pdText = pd.type.charAt(0).toUpperCase() + pd.type.slice(1);
        }
        const li = document.createElement('li');
        li.innerHTML = `<span class="item-text">${pdText}</span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.classList.add('delete-btn');
        delBtn.addEventListener('click', function() {
          paydays = paydays.filter(item => item.id !== pd.id);
          updatePaydayList();
        });
        li.appendChild(delBtn);
        paydayList.appendChild(li);
      });
    }

    /**************************************************************
     * Bank Account: Add a new bank account.
     **************************************************************/
    document.getElementById('bankAccountForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const name = document.getElementById('bankName').value;
      const balanceInput = document.getElementById('bankBalance').value;
      // For expense totals we now ignore the current balance; it’s only used if not tracking.
      const balance = balanceInput ? parseFloat(balanceInput) : (balanceTrackingEnabled ? 0 : null);
      const id = Date.now().toString() + "_bank";
      bankAccounts.push({ id, name, balance });
      updateBankAccountList();
      updateBankAccountDropdowns();
      updateDistributionSection();
      document.getElementById('bankName').value = '';
      document.getElementById('bankBalance').value = '';
    });

    /**************************************************************
     * Update Bank Accounts list UI.
     **************************************************************/
    function updateBankAccountList() {
      const bankList = document.getElementById('bankAccountList');
      bankList.innerHTML = "";
      bankAccounts.forEach(account => {
        const balText = (account.balance !== null && !isNaN(account.balance)) ? `$${account.balance.toFixed(2)}` : "N/A";
        const li = document.createElement('li');
        li.innerHTML = `<span class="item-text">${account.name} - Balance: ${balText}</span>`;
        if(balanceTrackingEnabled) {
          const editBtn = document.createElement('button');
          editBtn.textContent = "Edit";
          editBtn.classList.add('edit-btn');
          editBtn.addEventListener('click', function() {
            const newBalance = prompt("Enter new current balance for " + account.name, account.balance);
            if(newBalance !== null) {
              account.balance = parseFloat(newBalance);
              updateBankAccountList();
            }
          });
          li.insertBefore(editBtn, li.firstChild);
        }
        const delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.classList.add('delete-btn');
        delBtn.addEventListener('click', function() {
          bankAccounts = bankAccounts.filter(item => item.id !== account.id);
          recurringBills = recurringBills.filter(bill => bill.bankAccountId !== account.id);
          oneTimeExpenses = oneTimeExpenses.filter(exp => exp.bankAccountId !== account.id);
          updateBankAccountList();
          updateBankAccountDropdowns();
          updateDistributionSection();
          updateBillList();
          updateExpenseList();
        });
        li.appendChild(delBtn);
        bankList.appendChild(li);
      });
    }

    /**************************************************************
     * Recurring Bill: Add a new recurring bill.
     * Bills are now sorted in ascending order by due date.
     **************************************************************/
    document.getElementById('billForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const name = document.getElementById('billName').value;
      const amount = parseFloat(document.getElementById('billAmount').value);
      let dueDate = parseInt(document.getElementById('billDueDate').value);
      const bankAccountId = document.getElementById('billBankAccount').value;
      if (!bankAccountId) {
        alert("Please select a bank account for the bill.");
        return;
      }
      const id = Date.now().toString() + "_bill";
      recurringBills.push({ id, name, amount, dueDate, bankAccountId });
      updateBillList();
      document.getElementById('billName').value = '';
      document.getElementById('billAmount').value = '';
      document.getElementById('billDueDate').value = '';
      document.getElementById('billBankAccount').value = '';
    });

    /**************************************************************
     * Update Recurring Bills list UI.
     **************************************************************/
    function updateBillList() {
      const billList = document.getElementById('billList');
      billList.innerHTML = "";
      recurringBills.sort((a, b) => a.dueDate - b.dueDate);
      const days = getCycleDaysInMonth();
      recurringBills.forEach(bill => {
        const bankAccount = bankAccounts.find(acc => acc.id === bill.bankAccountId);
        const li = document.createElement('li');
        li.classList.add("bill-item");
        li.innerHTML = `<span class="item-text">${bill.name} - $${bill.amount.toFixed(2)} due on Day ${effectiveDueDate(bill.dueDate, days)} from ${bankAccount ? bankAccount.name : ""}</span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.classList.add('delete-btn');
        delBtn.addEventListener('click', function() {
          recurringBills = recurringBills.filter(item => item.id !== bill.id);
          updateBillList();
        });
        li.appendChild(delBtn);
        billList.appendChild(li);
      });
    }

    /**************************************************************
     * Expense Plan Type toggle.
     **************************************************************/
    const expensePlanTypeRadios = document.getElementsByName('expensePlanType');
    expensePlanTypeRadios.forEach(radio => {
      radio.addEventListener('change', function() {
        if(this.value === 'occurrence') {
          document.getElementById('occurrenceSection').classList.remove('hidden');
          document.getElementById('specificMonthsSection').classList.add('hidden');
        } else {
          document.getElementById('occurrenceSection').classList.add('hidden');
          document.getElementById('specificMonthsSection').classList.remove('hidden');
        }
      });
    });

    /**************************************************************
     * Specific Months: Add month selection for periodic expense.
     **************************************************************/
    document.getElementById('addExpenseMonthBtn').addEventListener('click', function() {
      const monthSelect = document.getElementById('expenseMonthSelect');
      const month = monthSelect.value;
      if (!tempExpenseMonths.includes(month)) {
        tempExpenseMonths.push(month);
        updateExpenseMonthsList();
      }
    });

    function updateExpenseMonthsList() {
      const list = document.getElementById('expenseMonthsList');
      list.innerHTML = "";
      tempExpenseMonths.forEach((m, index) => {
        const li = document.createElement('li');
        li.innerHTML = `<span class="item-text">${monthName(parseInt(m))}</span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.classList.add('delete-btn');
        delBtn.addEventListener('click', function() {
          tempExpenseMonths.splice(index, 1);
          updateExpenseMonthsList();
        });
        li.appendChild(delBtn);
        list.appendChild(li);
      });
    }

    function monthName(m) {
      const names = ["January","February","March","April","May","June","July","August","September","October","November","December"];
      return names[m - 1] || "";
    }

    /**************************************************************
     * Periodic Expense: Add a new periodic expense.
     **************************************************************/
    document.getElementById('expenseForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const name = document.getElementById('expenseName').value;
      const amount = parseFloat(document.getElementById('expenseAmount').value);
      let dueDate = parseInt(document.getElementById('expenseDueDate').value);
      const bankAccountId = document.getElementById('expenseBankAccount').value;
      if (!bankAccountId) {
        alert("Please select a bank account for the expense.");
        return;
      }
      let planType = document.querySelector('input[name="expensePlanType"]:checked').value;
      let occurrences = 0;
      let specificMonths = [];
      if(planType === 'occurrence') {
        occurrences = parseInt(document.getElementById('expenseOccurrences').value) || 0;
      } else if(planType === 'specific') {
        specificMonths = [...tempExpenseMonths];
        tempExpenseMonths = [];
        updateExpenseMonthsList();
      }
      const id = Date.now().toString() + "_expense";
      oneTimeExpenses.push({ id, name, amount, dueDate, bankAccountId, planType, occurrences, specificMonths });
      updateExpenseList();
      document.getElementById('expenseName').value = '';
      document.getElementById('expenseAmount').value = '';
      document.getElementById('expenseDueDate').value = '';
      document.getElementById('expenseBankAccount').value = '';
      document.getElementById('expenseOccurrences').value = '';
      document.querySelector('input[name="expensePlanType"][value="occurrence"]').checked = true;
      document.getElementById('occurrenceSection').classList.remove('hidden');
      document.getElementById('specificMonthsSection').classList.add('hidden');
    });

    /**************************************************************
     * Update Periodic Expenses list UI.
     **************************************************************/
    function updateExpenseList() {
      const expenseList = document.getElementById('expenseList');
      expenseList.innerHTML = "";
      oneTimeExpenses.forEach(exp => {
        const bankAccount = bankAccounts.find(acc => acc.id === exp.bankAccountId);
        let expText = `${exp.name} - $${exp.amount.toFixed(2)} due on Day ${exp.dueDate}`;
        if(exp.planType === 'occurrence' && exp.occurrences > 0) {
          expText += ` | Occurs ${exp.occurrences}x/yr`;
        } else if(exp.planType === 'specific' && exp.specificMonths.length > 0) {
          expText += ` | Due in: ${exp.specificMonths.map(m => monthName(parseInt(m))).join(', ')}`;
        } else {
          expText += " (One-Time)";
        }
        const li = document.createElement('li');
        li.classList.add("expense-item");
        li.innerHTML = `<span class="item-text">${expText} from ${bankAccount ? bankAccount.name : ""}</span>`;
        const delBtn = document.createElement('button');
        delBtn.textContent = "Delete";
        delBtn.classList.add('delete-btn');
        delBtn.addEventListener('click', function() {
          oneTimeExpenses = oneTimeExpenses.filter(item => item.id !== exp.id);
          updateExpenseList();
        });
        li.appendChild(delBtn);
        expenseList.appendChild(li);
      });
    }

    /**************************************************************
     * Helper: Compute expected pay periods per year based on paydays.
     **************************************************************/
    function getExpectedPayPeriodsPerYear() {
      let periods = 12;
      if (paydays.some(pd => pd.type === 'daily')) {
         periods = 365;
      } else if (paydays.some(pd => pd.type === 'weekly')) {
         periods = 52;
      } else if (paydays.some(pd => pd.type === '1st15')) {
         periods = 24;
      }
      return periods;
    }

    /**************************************************************
     * Helper: Compute next payday difference (in days) from the selected day.
     **************************************************************/
    function computeNextPaydayDiff(selectedDay, daysInMonth) {
      let differences = [];
      paydays.forEach(pd => {
        let diff = 0;
        if(pd.type === 'specific'){
          let pdDay = effectiveDueDate(pd.day, daysInMonth);
          if(pdDay >= selectedDay){
            diff = pdDay - selectedDay;
          } else {
            diff = (daysInMonth - selectedDay) + pdDay;
          }
        } else if(pd.type === '1st15'){
          if(selectedDay < 15){
            diff = 15 - selectedDay;
          } else {
            diff = daysInMonth - selectedDay;
          }
        } else if(pd.type === 'daily'){
          diff = 1;
        } else if(pd.type === 'weekly'){
          diff = 7;
        } else if(pd.type === 'monthly'){
          let pdDay = daysInMonth;
          if(selectedDay <= pdDay){
            diff = pdDay - selectedDay;
          } else {
            diff = (daysInMonth - selectedDay) + pdDay;
          }
        }
        differences.push(diff);
      });
      return Math.min(...differences);
    }

    /**************************************************************
     * Helper: Get the most recent payday day (needed by the calculation).
     **************************************************************/
    function getMostRecentPaydayDay(selectedDay, daysInMonth) {
      let recentDay = -1;
      let recentEffectiveDay = -1;
      paydays.forEach(pd => {
        let effDay;
        if(pd.type === 'specific') {
          effDay = effectiveDueDate(pd.day, daysInMonth);
        } else if(pd.type === '1st15') {
          effDay = (selectedDay >= 15) ? 15 : 1;
        } else if(pd.type === 'daily'){
          effDay = selectedDay;
        } else if(pd.type === 'weekly'){
          const offset = (selectedDay - 1) % 7; 
          effDay = selectedDay - offset;
        } else if(pd.type === 'monthly'){
          effDay = daysInMonth;
        }
        if(effDay <= selectedDay && effDay > recentEffectiveDay) {
          recentEffectiveDay = effDay;
          recentDay = effDay;
        }
      });
      if(recentDay === -1) {
        let fallbackDay = 1;
        paydays.forEach(pd => {
          let effDay;
          if(pd.type === 'specific'){
            effDay = effectiveDueDate(pd.day, daysInMonth);
          } else if(pd.type === '1st15'){
            effDay = 15;
          } else if(pd.type === 'daily'){
            effDay = selectedDay;
          } else if(pd.type === 'weekly'){
            effDay = 1; 
          } else if(pd.type === 'monthly'){
            effDay = daysInMonth;
          }
          if(effDay > fallbackDay) fallbackDay = effDay;
        });
        recentDay = fallbackDay;
      }
      return recentDay;
    }

    /**************************************************************
     * Calculation and Totals:
     * (Updated to compute surpluses correctly as per user feedback)
     **************************************************************/
    document.getElementById('calculateButton').addEventListener('click', function() {
      const cycleDateStr = document.getElementById('cycleDate').value;
      if (!cycleDateStr) {
        alert("Please select a cycle date.");
        return;
      }
      const cycleDate = new Date(cycleDateStr);
      const selectedDay = cycleDate.getDate();
      const currentDaysInMonth = new Date(cycleDate.getFullYear(), cycleDate.getMonth()+1, 0).getDate();

      if (paydays.length === 0 && !balanceTrackingEnabled) {
        alert("Please add at least one payday.");
        return;
      }

      const periodStart = getMostRecentPaydayDay(selectedDay, currentDaysInMonth);
      const nextDiff = computeNextPaydayDiff(selectedDay, currentDaysInMonth);
      let periodEnd = selectedDay + nextDiff;
      let fullPeriodLength = (periodEnd >= periodStart)
        ? (periodEnd - periodStart + 1)
        : ((currentDaysInMonth - periodStart + 1) + periodEnd);
      let remainingDays = (periodEnd >= selectedDay)
        ? (periodEnd - selectedDay + 1)
        : ((currentDaysInMonth - selectedDay + 1) + periodEnd);
      const periodEndDisplay = (periodEnd <= currentDaysInMonth)
        ? periodEnd
        : (periodEnd - currentDaysInMonth) + " [next cycle]";

      document.getElementById('payPeriodRange').textContent =
        `This section displays the expenses for the current pay period (Day ${periodStart} to Day ${periodEndDisplay}, ${fullPeriodLength} days).`;

      let paycheck = balanceTrackingEnabled 
                     ? parseFloat(document.getElementById('expectedPaycheck').value)
                     : 0;
      if(balanceTrackingEnabled && (isNaN(paycheck) || paycheck <= 0)) {
        alert("Please enter a valid Expected Paycheck Amount.");
        return;
      }

      // Compute required expenses for each bank account for the current pay period
      let requiredExpenses = {};
      bankAccounts.forEach(account => {
        const billsForAccount = recurringBills.filter(bill => {
          return bill.bankAccountId === account.id &&
                 isDueWithin(effectiveDueDate(bill.dueDate, currentDaysInMonth), selectedDay, periodEnd, currentDaysInMonth);
        });
        let totalBills = 0;
        billsForAccount.forEach(bill => {
          totalBills += bill.amount;
        });
        let totalPeriodic = 0;
        oneTimeExpenses.forEach(exp => {
          if(exp.bankAccountId === account.id) {
            if(exp.planType === 'occurrence' && exp.occurrences > 0) {
              totalPeriodic += (exp.amount * exp.occurrences) / getExpectedPayPeriodsPerYear();
            } else if(exp.planType === 'specific' && exp.specificMonths.length > 0) {
              if(exp.specificMonths.includes((cycleDate.getMonth()+1).toString()) &&
                 isDueWithin(exp.dueDate, selectedDay, periodEnd, currentDaysInMonth)
              ) {
                totalPeriodic += exp.amount;
              }
            } else {
              if(isDueWithin(exp.dueDate, selectedDay, periodEnd, currentDaysInMonth)) {
                totalPeriodic += exp.amount;
              }
            }
          }
        });
        requiredExpenses[account.id] = totalBills + totalPeriodic;
      });

      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = "";

      // For each bank account, calculate values for the Required Balances Summary
      let overallAllocated = 0;
      bankAccounts.forEach(account => {
        let allocated = 0;
        if(balanceTrackingEnabled) {
          const method = document.getElementById('distributionMethod').value;
          if(method === "equal") {
            allocated = paycheck / bankAccounts.length;
          } else if(method === "custom") {
            let input = document.getElementById('customAlloc_' + account.id);
            allocated = (input && input.value !== "" ? parseFloat(input.value) : (paycheck / bankAccounts.length));
          } else if(method === "single") {
            let selectedAccountId = document.getElementById('singleAccountSelector').value;
            allocated = (account.id === selectedAccountId) ? paycheck : 0;
          } else if(method === "proportional") {
            let totalReq = Object.values(requiredExpenses).reduce((a, b) => a + b, 0);
            allocated = (totalReq > 0)
              ? paycheck * (requiredExpenses[account.id] / totalReq)
              : (paycheck / bankAccounts.length);
          }
        }
        overallAllocated += allocated;
        const totalRequired = requiredExpenses[account.id] || 0;
        // Use the CURRENT bank balance for surplus calculation (assumes user has been paid)
        const currentBalance = (account.balance !== null && !isNaN(account.balance)) ? account.balance : 0;
        const surplus = currentBalance - totalRequired;
        const dailySpendBudget = remainingDays > 0 ? surplus / remainingDays : surplus;

        // Build the Required Balances Summary in the specified order:
        const accountDiv = document.createElement('div');
        accountDiv.classList.add('account-summary');
        const header = document.createElement('h3');
        header.textContent = account.name;
        accountDiv.appendChild(header);

        // a. Deposit for This Pay Period:
        const depositPara = document.createElement('p');
        depositPara.textContent = `Deposit for This Pay Period: $${allocated.toFixed(2)}`;
        accountDiv.appendChild(depositPara);

        // b. Current Balance for this Bank Account:
        const currentBalancePara = document.createElement('p');
        currentBalancePara.textContent = `Current Balance for this Bank Account: $${currentBalance.toFixed(2)}`;
        accountDiv.appendChild(currentBalancePara);

        // c. Remaining Expenses for This Pay Period for this account:
        const requiredPara = document.createElement('p');
        requiredPara.textContent = `Remaining Expenses for This Pay Period for this account: $${totalRequired.toFixed(2)}`;
        accountDiv.appendChild(requiredPara);

        // d. Estimated Surplus for This Pay Period:
        const surplusPara = document.createElement('p');
        if(surplus >= 0) {
          surplusPara.style.color = 'green';
          surplusPara.textContent = `Estimated Surplus for This Pay Period: $${surplus.toFixed(2)}`;
        } else {
          surplusPara.style.color = 'red';
          surplusPara.textContent = `Estimated Deficit for This Pay Period: $${Math.abs(surplus).toFixed(2)}`;
        }
        accountDiv.appendChild(surplusPara);

        // e. Daily Spend Budget for the Remainder of This Pay Period:
        const dailyPara = document.createElement('p');
        dailyPara.textContent = `Daily Spend Budget for the Remainder of This Pay Period (${remainingDays} days): $${dailySpendBudget.toFixed(2)}`;
        accountDiv.appendChild(dailyPara);

        // List upcoming items for this account
        const listHeader = document.createElement('p');
        listHeader.textContent = "Upcoming Bills/Expenses:";
        accountDiv.appendChild(listHeader);
        const list = document.createElement('ul');
        if(upcomingItemsForAccount(account.id, selectedDay, periodEnd, currentDaysInMonth).length === 0) {
          const li = document.createElement('li');
          li.textContent = "None";
          list.appendChild(li);
        } else {
          upcomingItemsForAccount(account.id, selectedDay, periodEnd, currentDaysInMonth).forEach(item => {
            const dueDay = effectiveDueDate(item.dueDate, currentDaysInMonth);
            let itemText = "";
            if(item.type === 'bill') {
              itemText = `${item.name} - $${item.amount.toFixed(2)} (Bill) due on Day ${dueDay}`;
            } else {
              if(item.planType === 'occurrence' && item.occurrences > 0) {
                itemText = `${item.name} - $${item.amount.toFixed(2)} (Expense, Occurs ${item.occurrences}x/yr) due on Day ${dueDay}`;
              } else if(item.planType === 'specific' && item.specificMonths.length > 0) {
                itemText = `${item.name} - $${item.amount.toFixed(2)} (Expense, Due in: ${item.specificMonths.map(m => monthName(parseInt(m))).join(', ')}) due on Day ${dueDay}`;
              } else {
                itemText = `${item.name} - $${item.amount.toFixed(2)} (Expense, One-Time) due on Day ${dueDay}`;
              }
            }
            const li = document.createElement('li');
            li.textContent = itemText;
            list.appendChild(li);
          });
        }
        accountDiv.appendChild(list);
        resultsDiv.appendChild(accountDiv);
      });

      // Expense Totals: Pay-Period calculations
      let combinedPayPeriod = 0;
      bankAccounts.forEach(acc => {
        combinedPayPeriod += requiredExpenses[acc.id] || 0;
      });
      // Here, Estimated Surplus for this pay period = (Expected Income) - (Combined Expenses)
      let overallSurplus = paycheck - combinedPayPeriod;
      document.getElementById('payPeriodCombined').innerHTML =
        `<strong>Total Expenses for This Pay Period:</strong> $${combinedPayPeriod.toFixed(2)}<br>` +
        `<span style="color:${overallSurplus >= 0 ? 'green' : 'red'};">Estimated Surplus for This Pay Period: $${overallSurplus.toFixed(2)}</span>`;

      // Monthly Totals Calculations
      let monthlyTotals = {};
      bankAccounts.forEach(acc => {
        monthlyTotals[acc.id] = 0;
      });
      recurringBills.forEach(bill => {
        monthlyTotals[bill.bankAccountId] += bill.amount;
      });
      oneTimeExpenses.forEach(exp => {
        if(exp.planType === 'occurrence' && exp.occurrences > 0) {
          monthlyTotals[exp.bankAccountId] += (exp.amount * exp.occurrences) / 12;
        } else if(exp.planType === 'specific' && exp.specificMonths.length > 0) {
          if(exp.specificMonths.includes((cycleDate.getMonth()+1).toString())) {
            monthlyTotals[exp.bankAccountId] += exp.amount;
          }
        }
      });
      let combinedMonthly = 0;
      for (let id in monthlyTotals) {
        combinedMonthly += monthlyTotals[id];
      }
      // Compute expected monthly allocations based on distribution method
      let expectedPayPeriodsPerYear = getExpectedPayPeriodsPerYear();
      let monthlyPaycheck = paycheck * (expectedPayPeriodsPerYear / 12);
      let monthlyBankList = "";
      bankAccounts.forEach(acc => {
        let monthlyAllocated = 0;
        if(balanceTrackingEnabled) {
          const method = document.getElementById('distributionMethod').value;
          if(method === "equal") {
            monthlyAllocated = monthlyPaycheck / bankAccounts.length;
          } else if(method === "custom") {
            let input = document.getElementById('customAlloc_' + acc.id);
            let perPay = (input && input.value !== "" ? parseFloat(input.value) : (paycheck / bankAccounts.length));
            monthlyAllocated = perPay * (expectedPayPeriodsPerYear / 12);
          } else if(method === "single") {
            let selectedAccountId = document.getElementById('singleAccountSelector').value;
            monthlyAllocated = (acc.id === selectedAccountId) ? monthlyPaycheck : 0;
          } else if(method === "proportional") {
            let totalReq = Object.values(requiredExpenses).reduce((a, b) => a + b, 0);
            monthlyAllocated = (totalReq > 0)
              ? monthlyPaycheck * (requiredExpenses[acc.id] / totalReq)
              : (monthlyPaycheck / bankAccounts.length);
          }
        }
        const surplusMonthly = monthlyAllocated - (monthlyTotals[acc.id] || 0);
        monthlyBankList += `<h4>${acc.name} - Total Expenses: $${monthlyTotals[acc.id].toFixed(2)}</h4>`;
        monthlyBankList += `<p>Estimated Monthly Deposit for ${acc.name}: $${monthlyAllocated.toFixed(2)}</p>`;
        if(surplusMonthly >= 0) {
          monthlyBankList += `<p style="color:green;">Estimated Monthly Surplus for ${acc.name}: $${surplusMonthly.toFixed(2)}</p>`;
        } else {
          monthlyBankList += `<p style="color:red;">Estimated Monthly Deficit for ${acc.name}: $${Math.abs(surplusMonthly).toFixed(2)}</p>`;
        }
        let billsList = "<ul>";
        recurringBills.filter(bill => bill.bankAccountId === acc.id).forEach(bill => {
          billsList += `<li>${bill.name} - $${bill.amount.toFixed(2)} due on Day ${bill.dueDate}</li>`;
        });
        oneTimeExpenses.filter(exp => exp.bankAccountId === acc.id).forEach(exp => {
          if(exp.planType === 'occurrence' && exp.occurrences > 0) {
            billsList += `<li>${exp.name} - $${exp.amount.toFixed(2)} (Occurs ${exp.occurrences}x/yr)</li>`;
          } else if(exp.planType === 'specific' && exp.specificMonths.includes((cycleDate.getMonth()+1).toString())) {
            billsList += `<li>${exp.name} - $${exp.amount.toFixed(2)} (Due in: ${exp.specificMonths.map(m => monthName(parseInt(m))).join(', ')})</li>`;
          }
        });
        billsList += "</ul>";
        monthlyBankList += billsList;
      });
      // Display Combined Monthly Expenses and add Estimated Monthly Surplus
      document.getElementById('monthlyCombined').innerHTML =
        `<strong>Combined Monthly Expenses:</strong> $${combinedMonthly.toFixed(2)}`;
      let monthlySurplus = monthlyPaycheck - combinedMonthly;
      document.getElementById('monthlyCombined').innerHTML += `<br><span style="color:${monthlySurplus >= 0 ? 'green' : 'red'};">Estimated Surplus for This Month: $${monthlySurplus.toFixed(2)}</span>`;
      document.getElementById('monthlyByBank').innerHTML = monthlyBankList;
    });

    // Helper function to get upcoming items for a given bank account
    function upcomingItemsForAccount(accountId, selectedDay, periodEnd, daysInMonth) {
      let items = [];
      items = items.concat(
        recurringBills.filter(bill => bill.bankAccountId === accountId && isDueWithin(effectiveDueDate(bill.dueDate, daysInMonth), selectedDay, periodEnd, daysInMonth))
          .map(bill => ({...bill, type: 'bill'}))
      );
      items = items.concat(
        oneTimeExpenses.filter(exp => {
          if(exp.bankAccountId !== accountId) return false;
          if(exp.planType === 'occurrence' && exp.occurrences > 0) {
            return isDueWithin(exp.dueDate, selectedDay, periodEnd, daysInMonth);
          } else if(exp.planType === 'specific' && exp.specificMonths.length > 0) {
            return exp.specificMonths.includes((new Date(document.getElementById('cycleDate').value).getMonth()+1).toString()) &&
                   isDueWithin(exp.dueDate, selectedDay, periodEnd, daysInMonth);
          } else {
            return isDueWithin(exp.dueDate, selectedDay, periodEnd, daysInMonth);
          }
        }).map(exp => ({...exp, type: 'expense'}))
      );
      items.sort((a, b) => {
        const aEff = effectiveDueDate(a.dueDate, daysInMonth);
        const bEff = effectiveDueDate(b.dueDate, daysInMonth);
        const aDue = aEff < selectedDay ? aEff + daysInMonth : aEff;
        const bDue = bEff < selectedDay ? bEff + daysInMonth : bEff;
        return aDue - bDue;
      });
      return items;
    }

    /**************************************************************
     * CSV Import for Recurring Bills.
     **************************************************************/
    document.getElementById('recurringCSV').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      if (!file.name.toLowerCase().endsWith('.csv')) {
        alert("Please upload a file in .csv format.");
        return;
      }
      const reader = new FileReader();
      reader.onload = function(evt) {
        try {
          const csvData = evt.target.result;
          const lines = csvData.split(/\r\n|\n/).filter(line => line.trim() !== '');
          if (lines.length < 2) {
            alert("CSV file does not contain any data rows.");
            return;
          }
          const headers = lines[0].split(',').map(h => h.trim());
          const requiredHeaders = ["Bill Name", "Bill Amount", "Due Date", "Bank Account"];
          for (let header of requiredHeaders) {
            if (!headers.includes(header)) {
              alert("Recurring Bills CSV is missing required column: " + header);
              return;
            }
          }
          const data = [];
          const errors = [];
          for (let i = 1; i < lines.length; i++) {
            const line = lines[i];
            if (line.trim() === "") continue;
            const fields = line.split(',');
            const rowObj = {};
            headers.forEach((header, index) => {
              rowObj[header] = fields[index] ? fields[index].trim() : "";
            });
            if (!rowObj["Bill Name"] || !rowObj["Bill Amount"] || !rowObj["Due Date"] || !rowObj["Bank Account"]) {
              errors.push(`Row ${i+1}: Missing required data.`);
              continue;
            }
            const amount = parseFloat(rowObj["Bill Amount"]);
            if (isNaN(amount) || amount <= 0) {
              errors.push(`Row ${i+1}: Bill Amount must be a positive number.`);
              continue;
            }
            const dueDate = parseInt(rowObj["Due Date"]);
            if (isNaN(dueDate) || dueDate < 1 || dueDate > 31) {
              errors.push(`Row ${i+1}: Due Date must be between 1 and 31.`);
              continue;
            }
            let bankAcc = bankAccounts.find(acc => acc.name.toLowerCase() === rowObj["Bank Account"].toLowerCase());
            if (!bankAcc) {
              const bankId = Date.now().toString() + "_bank_csv_" + i;
              const newBank = { id: bankId, name: rowObj["Bank Account"], balance: null };
              bankAccounts.push(newBank);
              updateBankAccountList();
              updateBankAccountDropdowns();
              updateDistributionSection();
              bankAcc = newBank;
            }
            data.push({
              id: Date.now().toString() + "_bill" + i,
              name: rowObj["Bill Name"],
              amount: amount,
              dueDate: dueDate,
              bankAccountId: bankAcc.id
            });
          }
          if (errors.length > 0) {
            alert("Errors found while parsing CSV:\n" + errors.join("\n"));
            return;
          }
          data.forEach(bill => recurringBills.push(bill));
          updateBillList();
          alert("Recurring bills imported successfully.");
        } catch (err) {
          console.error(err);
          alert("An error occurred while processing the CSV file: " + err.message);
        }
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
